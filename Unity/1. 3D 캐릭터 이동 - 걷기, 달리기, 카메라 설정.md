## ğŸ¦„ 3D ìºë¦­í„° ì´ë™ - ê±·ê¸°, ë‹¬ë¦¬ê¸°, ì¹´ë©”ë¼ ì„¤ì •



### 1. ë°”ë‹¥ì´ ë  [3D Object] - [Cube] ìƒì„±

* ì˜¤ë¸Œì íŠ¸ì˜ ìƒ‰ìƒì´ í°ìƒ‰ì´ ì•„ë‹ˆë¼ ì¹™ì¹™í•  ê²½ìš°
  * [Window] - [Rendering] - [Lighting Settings] - [Generate Lighting]ì„ í†µí•´ ë¹› ìƒì„±
* Cubeì˜ í¬ê¸° ì§€ì • : (100, 1, 100)



### 2. ë²½ì´ ë  [3D Object] - [Cube] 4ê°œ ìƒì„±

* 4ê°œì˜ íë¸Œ ì˜¤ë¸Œì íŠ¸ë¡œ ë²½ ìƒì„±
* [Inspector] - [Mesh Renderer] ì²´í¬ í•´ì œë¥¼ í†µí•´ ColliderëŠ” ìœ ì§€í•˜ì§€ë§Œ ê²‰ë³´ê¸°ë§Œ ê°ì¶”ê¸° ê°€ëŠ¥

### 3. Material ì„¤ì •

* [ìš°í´ë¦­] - [create] - [Material]
* Albedo ì¢Œì¸¡ ë²„íŠ¼ : ê¸°ë³¸ ì œê³µë˜ëŠ” í…ìŠ¤ì²˜ ì„ íƒ ê°€ëŠ¥
* Albedo ìš°ì¸¡ : ìƒ‰ìƒ ì§€ì • ê°€ëŠ¥
* Tiling : ìˆ«ìë¥¼ ëŠ˜ë ¤ì„œ í…ìŠ¤ì³ë¥¼ íƒ€ì¼ í˜•íƒœë¡œ ë°°ì¹˜

![Material](./Image/Material.PNG)

### 4. ìƒì„±í•œ Materialì„ Objectì— ì ìš©

* ìƒì„±í•œ Materialì„ Objectì˜ ì»´í¬ë„ŒíŠ¸ë¡œ ì¶”ê°€



### 5. 3D ìºë¦­í„° ìƒì„±

* Prefab : ê²Œì„ ì˜¤ë¸Œì íŠ¸ë¥¼ ì—ì…‹ìœ¼ë¡œ ë³´ê´€ëœ í˜•íƒœ, ë¯¸ë¦¬ ë§Œë“¤ì–´ì§„ ì˜¤ë¸Œì íŠ¸
* â— ìºë¦­í„°ì˜ í•„ìš”í•œ ì»´í¬ë„ŒíŠ¸ : **Capsule Collider + Rigidbody + Script**
  * Rigidbody : ë¬¼ë¦¬ íš¨ê³¼
  * Capsule Collider : ìµœì  ì¶©ëŒ
  * Script : C# ìŠ¤í¬ë¦½íŠ¸,  Add Component ë˜ëŠ” ëŒì–´ë†“ê¸°ë¥¼ í†µí•´ ì»´í¬ë„ŒíŠ¸ì— ì¶”ê°€

* Capsule Collider ì„¤ì • : ìºë¦­í„°ì˜ ì¤‘ì•™ì— ìœ„ì¹˜í•˜ë©° ìºë¦­í„° ì „ì²´ë¥¼ ê°ìŒ€ ìˆ˜ ìˆë„ë¡ í¬ê¸° ì¡°ì ˆ

![Capsule Collider](./Image/Capsule Collider.PNG)



### 6. ìºë¦­í„° ê¸°ë³¸ ì´ë™ êµ¬í˜„

```c#
public class Player : MonoBehaviour
{

    public float speed; // ì¸ìŠ¤í™í„° ì°½ì—ì„œ ì„¤ì •í•  ìˆ˜ ìˆë„ë¡ public ë³€ìˆ˜ ì¶”ê°€

    // Input Axis ê°’ì„ ë°›ì„ ì „ì—­ë³€ìˆ˜ ì„ ì–¸
    float hAxis;
    float vAxis;

    Vector3 moveVec;

    void Start()
    {
        
    }

    void Update()
    {
        hAxis = Input.GetAxisRaw("Horizontal"); 
        vAxis = Input.GetAxisRaw("Vertical");

        moveVec = new Vector3(hAxis, 0, vAxis).normalized; 
        // Vector3(x, y, z)
        // normalized : ë°©í–¥ ê°’ì´ 1ë¡œ ë³´ì •ëœ ë²¡í„°
        
		transform.position += moveVec * speed * Time.deltaTime;
    }
}

```

* Horizontalê³¼ Verticalì€ ë­˜ê¹Œ?

  * [Edit] - [Project Settings] - [Input Manager] - [Axes] 
  * Input Managerì—ì„œ ê´€ë¦¬, Nameì„ ì›í•˜ëŠ” ëŒ€ë¡œ ë°”ê¾¸ì–´ì„œ ì‚¬ìš© ê°€ëŠ¥
  * https://docs.unity3d.com/kr/2021.3/Manual/class-InputManager.html

  ![Input Manager](./Image/Input Manager.PNG)

* Vector3 
  * 3D ë²¡í„°ì˜ ê°’ì„ í‘œí˜„í•˜ê¸° ìœ„í•œ ë°ì´í„° íƒ€ì…
  * transform ì´ë™ì€ ë¬´ì¡°ê±´ Vector3ë¥¼ ì‚¬ìš©
  * xì¶•ì€ Horizontal, zì¶•ì€ Verticalì„ ì‚¬ìš©
* normalized
  * ì˜¤ë¸Œì íŠ¸ ê· ì¼í•œ ì´ë™ì„ ìœ„í•œ ë²¡í„°ì˜ ì •ê·œí™”
  * ë°©í–¥ ê°’ì´ 1ë¡œ ë³´ì •ëœ ë²¡í„°ë¡œ ì–´ë–¤ ë°©í–¥ì´ë“  ê°™ì€ ê°’(ì†ë„)ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•¨
* publicìœ¼ë¡œ ë³€ìˆ˜ ì„ ì–¸ ì‹œ Inspectorì—ì„œ ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆìŒ

![Public Speed](./Image/Public Speed.PNG)

### # ê´€ì„±ì— ì˜í•´ ìºë¦­í„°ê°€ ë„˜ì–´ì§€ì§€ ì•Šë„ë¡ ì„¤ì •

* [Inspector] - [Rigidbody] - [Constraints] - [Freeze Rotation] - [X], [Z] ì²´í¬



### # ìºë¦­í„°ì˜ transform ì´ë™ì´ ë¬¼ë¦¬ ì¶©ëŒì„ ë¬´ì‹œí•˜ëŠ” ê²½ìš° í•´ê²° ë°©ë²•

* [Inspector] - [Rigidbody] - [Collision Detection] - "Continuous" ë³€ê²½

* ë²½ì— Colliderë¥¼ ë„£ì–´ë„ ë¬¼ì²´ë¥¼ í†µê³¼í•˜ëŠ” ê²½ìš°
  * ë¬¼ì²´ì˜ ê°€ì†ë„ê°€ ì¼ì •ëŸ‰ ì´ìƒìœ¼ë¡œ ì˜¬ë¼ê°€ë©´ ìƒê¸°ëŠ” ë²„ê·¸
  * [Inspector] - [Rigidbody] - [Interpolate] - "Extrapolate" ë³€ê²½
  * [Inspector] - [Rigidbody] - [Collision Detection] - "Continuous Dynamic" ë³€ê²½ : ì„±ëŠ¥ì´ ë§ì´ ë–¨ì–´ì§€ê¸° ë•Œë¬¸ì— ì¶”ì²œí•˜ì§€ ì•ŠìŒ!
  * 



### 7. ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜ ìƒì„±

* [Create] - [Animator Controller] ìƒì„±

* ìƒì„±í•œ Controllerë¥¼ ìºë¦­í„°ì˜ ìì‹ ì˜¤ë¸Œì íŠ¸(Mesh Object)ì— ëŒì–´ë†“ê¸°

![Animator](./Image/Animator.PNG)



### 8. Animator Controller 

![Animator Run Walk](./Image/Animator Run Walk.png)

* Shiftë¥¼ ëˆ„ë¥´ë©´ ê±·ê¸° -> ë‹¬ë¦¬ê¸°
* ê° ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœë¥¼ [ìš°í´ë¦­] - [Make Transition]ì„ í†µí•´ ì—°ê²°
* Parameters : ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœë¥¼ ë°”ê¾¸ê¸° ìœ„í•œ ì¡°ê±´
* Idle -> Walk : isWalk = true
* Walk -> Idle : isWalk = false
* Walk -> Run : isRun = true
* Run -> Walk : isRun = false
* Run -> Idle : isWalk = false // Shiftë¥¼ ë–¼ë„ ë‹¬ë¦¬ê¸°ì—ì„œ ê±·ê¸°, ê±·ê¸°ì—ì„œ ë©ˆì¶”ê¸°ë¥¼ ìœ„í•¨
* Idle -> Run : isWalk = true, isRun = true (ê±·ê¸°ì™€ ë‹¬ë¦¬ê¸° ë‘˜ ë‹¤ ë§Œì¡±í•´ì•¼ í•¨)

* Transition ì„ íƒ í›„ Inspector ì„¤ì •
  * [Has exit Time] ì²´í¬ í•´ì œ
  * [Settings] - [Transition Duratior] ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ ì„¤ì •
  * [Conditions] ì¡°ê±´ ì¶”ê°€

![Animator Inspector](./Image/Animator Inspector.PNG)

![Input Manager Run](./Image/Input Manager Run.PNG)

* Size ì¡°ì ˆì„ í†µí•´ Axes ì†ì„±ì„ ì¶”ê°€ ê°€ëŠ¥

  * Name : Run
  * Positive button : left shift
  * ì™¼ìª½ shiftë¥¼ ëˆ„ë¥´ë©´ Run

  

```c#
// Player.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{

    public float speed;

    float hAxis;
    float vAxis;
    bool runDown; // runDown : Shiftë¥¼ ëˆ„ë¥´ë©´ ë‹¬ë¦¬ê¸°

    Vector3 moveVec;

    Animator anim;

    void Start()
    {
        // Animator ì»´í¬ë„ŒíŠ¸ ê°€ì ¸ì˜¤ê¸°
        // Animator ì»´í¬ë„ŒíŠ¸ë¥¼ Player ì•ˆì— Childë¡œ ë„£ì–´ë†“ì•˜ê¸° ë•Œë¬¸ì— ê°€ì ¸ì˜¬ ë•Œ ë˜í•œ GetComponentê°€ ì•„ë‹Œ GetComponentInChildë¥¼ ì´ìš©í•´ì•¼ í•¨
        anim = GetComponentInChildren<Animator>();
    }   

    void Update()
    {
        hAxis = Input.GetAxis("Horizontal");
        vAxis = Input.GetAxis("Vertical");
        runDown = Input.GetButton("Run"); // Left Shift ë²„íŠ¼ì„ ê¾¹ ëˆ„ë¥´ê³ (=>GetButton) ìˆì–´ì•¼ë§Œ ë‹¬ë¦¬ê¸° ê°€ëŠ¥ 


        moveVec = new Vector3(hAxis, 0, vAxis).normalized; // x, y, z
                                                           // normalized : ì–´ë–¤ ë°©í–¥ì´ë“  ê°™ì€ ê°’(ì†ë„)ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•¨, ë°©í–¥ ê°’ì´ 1ë¡œ ë³´ì •ëœ ë²¡í„°

        if(runDown) // ë‹¬ë¦¬ê¸°
            transform.position += moveVec * speed* Time.deltaTime; // transform ì´ë™ì€ ê¼­ Time.deltaTimeê¹Œì§€ ê³±í•´ì¤Œ!
        else // ê±·ê¸°
            transform.position += moveVec * speed * 0.3f * Time.deltaTime; // ê±·ê¸°ëŠ” ì†ë„ê°€ ë” ëŠë¦¬ê¸° ë•Œë¬¸ì— *0.3f

        // SetBool í•¨ìˆ˜ë¡œ íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •
        anim.SetBool("isWalk", moveVec != Vector3.zero);
        anim.SetBool("isRun", runDown);

        // ì•ìœ¼ë¡œ ë‚˜ì•„ê°€ëŠ” ë°©í–¥ì„ ë°”ë¼ë³¸ë‹¤.
        transform.LookAt(transform.position + moveVec);
    }
}

```

* Input.GetAxis() : -1, 0, 1, ì„¸ ê°€ì§€ ê°’ ì¤‘ í•˜ë‚˜ê°€ ë°˜í™˜, í‚¤ë³´ë“œ ê°’ì„ ëˆŒë €ì„ ë•Œ ì¦‰ì‹œ ë°˜ì‘í•´ì•¼ í•  ê²½ìš°ì— ì‚¬ìš©
* Input.GetAxisRaw() : -1.0f ~ 1.0f ê¹Œì§€ì˜ ë²”ìœ„ì˜ ê°’ì„ ë°˜í™˜, ë¶€ë“œëŸ¬ìš´ ì´ë™ì´ í•„ìš”í•œ ê²½ìš°ì— ì‚¬ìš©
* Time.deltaTime() : Time.deltaTimeì„ ì‚¬ìš©í•˜ë©´ í”„ë ˆì„ì´ ë‹¬ë¼ì ¸ë„ ë™ì¼í•œ ì„±ëŠ¥ì„ ë‚¼ ìˆ˜ ìˆìŒ



### 9. ê¸°ë³¸ íšŒì „ êµ¬í˜„

```c#
// ì•ìœ¼ë¡œ ë‚˜ì•„ê°€ëŠ” ë°©í–¥ì„ ë°”ë¼ë³¸ë‹¤.
transform.LookAt(transform.position + moveVec);
```



### 10. ì¹´ë©”ë¼ ì´ë™

```c#
// Follow.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Follow : MonoBehaviour
{
    // ì¹´ë©”ë¼ê°€ ë”°ë¼ë‹¤ë…€ì•¼ í•  íƒ€ê²Ÿ
    public Transform target;
    // ë³´ì •ê°’:  ë”°ë¼ê°ˆ ëª©í‘œì™€ ìœ„ì¹˜ ì˜¤í”„ì…‹ì„ public ë³€ìˆ˜ë¡œ ì„ ì–¸
    public Vector3 offset;

    void Update()
    {
        transform.position = target.position + offset;        
    }
}

```

![Main Camera](./Image/Main Camera.PNG)

* Main Cameraì— "Follow.cs" Script Component ì¶”ê°€
* Target : ë”°ë¼ë‹¤ë…€ì•¼ í•  ìºë¦­í„° ì„¤ì •
* Offset : ìºë¦­í„°ì˜ ìœ„ì¹˜ì™€ ë™ì¼í•œ ì¢Œí‘œë¥¼ ë„£ê³ , ì›í•˜ëŠ” ì¹´ë©”ë¼ ìœ„ì¹˜ë¡œ ì¢Œí‘œ ì„¤ì •



------

### 11. ìºë¦­í„° ê±·ê¸°, ë‹¬ë¦¬ê¸°ê¹Œì§€ ìµœì¢… ì½”ë“œ(í•¨ìˆ˜ ì •ë¦¬)

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{

    public float speed;

    float hAxis;
    float vAxis;
    bool runDown; // runDown : Shiftë¥¼ ëˆ„ë¥´ë©´ ë‹¬ë¦¬ê¸°

    Vector3 moveVec;

    Animator anim;

    void Start()
    {
        // Animator ì»´í¬ë„ŒíŠ¸ ê°€ì ¸ì˜¤ê¸°
        // Animator ì»´í¬ë„ŒíŠ¸ë¥¼ Player ì•ˆì— Childë¡œ ë„£ì–´ë†“ì•˜ê¸° ë•Œë¬¸ì— ê°€ì ¸ì˜¬ ë•Œ ë˜í•œ GetComponentê°€ ì•„ë‹Œ GetComponentInChildë¥¼ ì´ìš©í•´ì•¼ í•¨
        anim = GetComponentInChildren<Animator>();
    }   

    void Update()
    {
        GetInput(); // ì œì¼ ìœ„ì— ì‘ì„±

        Move();
        Turn();
    }

    void GetInput()
    {
        hAxis = Input.GetAxis("Horizontal");
        vAxis = Input.GetAxis("Vertical");
        runDown = Input.GetButton("Run"); // Left Shift ë²„íŠ¼ì„ ê¾¹ ëˆ„ë¥´ê³ (=>GetButton) ìˆì–´ì•¼ë§Œ ë‹¬ë¦¬ê¸° ê°€ëŠ¥ 
    }

    void Move()
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized; // x, y, z
                                                           // normalized : ì–´ë–¤ ë°©í–¥ì´ë“  ê°™ì€ ê°’(ì†ë„)ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•¨, ë°©í–¥ ê°’ì´ 1ë¡œ ë³´ì •ëœ ë²¡í„°

        if (runDown) // ë‹¬ë¦¬ê¸°
            transform.position += moveVec * speed * 3.0f * Time.deltaTime; // transform ì´ë™ì€ ê¼­ Time.deltaTimeê¹Œì§€ ê³±í•´ì¤Œ!
        else // ê±·ê¸°
            transform.position += moveVec * speed * 1f * Time.deltaTime; // ê±·ê¸°ëŠ” ì†ë„ê°€ ë” ëŠë¦¬ê¸° ë•Œë¬¸ì— *0.3f

        // SetBool í•¨ìˆ˜ë¡œ íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •
        anim.SetBool("isWalk", moveVec != Vector3.zero);
        anim.SetBool("isRun", runDown);
    }

    void Turn()
    {
        // ë‚˜ì•„ê°€ëŠ” ë°©í–¥ì„ ë°”ë¼ë³¸ë‹¤.
        transform.LookAt(transform.position + moveVec);
    }
}

```



### 12. ìºë¦­í„° ì í”„ ì½”ë“œ êµ¬í˜„

* Floor ì˜¤ë¸Œì íŠ¸ì— íƒœê·¸ ì¶”ê°€
* [Inspector] - [Tag] - [Add Tag] - [+] - "ì‚¬ìš©í•  íƒœê·¸ëª… ì§€ì •"

![Floor Tag](./Image/Floor Tag.PNG)

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{

    public float speed;
    public float jumpPower;

    float hAxis;
    float vAxis;
    bool runDown; 
    bool jumpDown; // jumpDown : Spaceë¥¼ ëˆ„ë¥´ë©´ ì í”„

    bool isJump; // ì í”„ ìˆ˜í–‰ ì—¬ë¶€

    Vector3 moveVec;

    Rigidbody rigid; // ë¬¼ë¦¬ íš¨ê³¼ë¥¼ ìœ„í•´ Rigidbody ë³€ìˆ˜ ì„ ì–¸
    Animator anim;

    void Start()
    {
        anim = GetComponentInChildren<Animator>();
        rigid = GetComponent<Rigidbody>(); // Childì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— GetComponent ì‚¬ìš© 
    }   

    void Update()
    {
        GetInput(); 

        Move();
        Turn();  
        Jump();
    }

    void GetInput()
    {
        hAxis = Input.GetAxis("Horizontal");
        vAxis = Input.GetAxis("Vertical");
        runDown = Input.GetButton("Run"); 
        jumpDown = Input.GetButtonDown("Jump"); // Spaceë¥¼ ëˆ„ë¥´ëŠ” ì¦‰ì‹œ ì í”„
    }

    void Move()
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized; 
        if (runDown) // ë‹¬ë¦¬ê¸°
            transform.position += moveVec * speed * 3.0f * Time.deltaTime; 
        else 
            transform.position += moveVec * speed * 1f * Time.deltaTime; 


        anim.SetBool("isWalk", moveVec != Vector3.zero);
        anim.SetBool("isRun", runDown);
    }

    void Turn()
    {
        transform.LookAt(transform.position + moveVec);
    }

    void Jump()
    {
        if(jumpDown && !isJump) // Spaceë¥¼ ëˆŒë €ê³ , ì í”„ ì¤‘ì¸ ìƒíƒœê°€ ì•„ë‹ ë•Œ => ì í”„ ê°€ëŠ¥
        {
            rigid.AddForce(Vector3.up * jumpPower, ForceMode.Impulse); // AddForce í•¨ìˆ˜ë¡œ ë¬¼ë¦¬ì ì¸ í˜ì„ ê°€í•  ìˆ˜ ìˆìŒ
            isJump = true;
        }

    }

    // ì¶©ëŒ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” í•¨ìˆ˜
    private void OnCollisionEnter(Collision collision)
    {
        // ì¶©ëŒí•œ ê²Œì„ ì˜¤ë¸Œì íŠ¸ì˜ íƒœê·¸ê°€ "Floor" ì¼ ê²½ìš°
        if(collision.gameObject.tag == "Floor")
        {
            isJump = false; // ë°”ë‹¥ê³¼ ì¶©ëŒ
        }
    }
}

```



### 13. ìºë¦­í„° ì í”„ ì• ë‹ˆë©”ì´ì…˜

* AnyStateë¡œ ì–´ë–¤ ìƒíƒœì—ì„œë“  ì‹¤í–‰, Exitìœ¼ë¡œ ì›ìƒë³µê·€
* AnyStateì—ì„œ ë‚˜ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜ì€ ëª¨ë‘ ì¼íšŒì„± ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ Trigger íŒŒë¼ë¯¸í„° ì‚¬ìš©
  * [+] - [Trigger] - "doJump", "doDodge" ìƒì„±
  * [+] - [bool] - "isJump" ìƒì„±

* DodgeëŠ” íšŒí”¼ ë™ì‘ìœ¼ë¡œ ë³¸ í”„ë¡œì íŠ¸ì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•Šì„ ë“¯

![Animator Jump](C:\Users\multicampus\Desktop\Unity\Typora\Basic Character\Animator Jump.PNG)

### 14. í”„ë¡œì íŠ¸ ì¤‘ë ¥ ì„¤ì •

* [Edit] - [Project Settings] - [Physics] - [Gravity] - Default = -9.81 -> -25ë¡œ ë³€ê²½
* ì¤‘ë ¥ì´ ì»¤ì§ˆìˆ˜ë¡ JumpPowerê°€ ì•½í•´ì§ -> JumpPower ê°’ ìˆ˜ì¹˜ ë³€ê²½



### 15. ì§€í˜• ë¬¼ë¦¬ ê°•í™”

* ëª¨ë“  ë§µ ì˜¤ë¸Œì íŠ¸ë¥¼ ì •ì ìœ¼ë¡œ ë³€ê²½

* [Inspector] - [Static] ì²´í¬ - [Yes]

* Staticìœ¼ë¡œ ë°”ê¾¸ëŠ” ì´ìœ ëŠ”?

  * ìºë¦­í„°ì˜ transform ì´ë™ì´ ë¬¼ë¦¬ ì¶©ëŒì„ ë¬´ì‹œí•˜ëŠ” ê²ƒì„ í•´ê²°í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ìºë¦­í„°ì˜ [Inspector] - [Collision Dection] - "Continuous"ë¡œ ì„¤ì •
  * [Collision Dection] - "Continuous"ëŠ” Staticê³¼ ì¶©ëŒí•  ë•Œ íš¨ê³¼ì 

  ![Object Static](C:\Users\multicampus\Desktop\Unity\Typora\Basic Character\Object Static.PNG)

* ë‘ ë¬¼ì²´ê°€ ì¶©ëŒí•  ë•Œ, ìœ ë‹ˆí‹°ê°€ íš¨ê³¼ì ìœ¼ë¡œ ì¶©ëŒ ê³„ì‚°ì„ í•˜ê¸° ìœ„í•´ì„œëŠ” ë‘ ë¬¼ì²´ê°€ Rigidbodyë¥¼ ê°–ëŠ” ê²ƒì´ ì¢‹ìŒ

  * ìºë¦­í„°ëŠ” Rigidbody ì»´í¬ë„ŒíŠ¸ë¥¼ ê°–ì§€ë§Œ, ì§€í˜• ì˜¤ë¸Œì íŠ¸ëŠ” Rigidbodyê°€ ì—†ê¸° ë•Œë¬¸ì— ì¶”ê°€í•´ì¤Œ
  * ì§€í˜• ì˜¤ë¸Œì íŠ¸ì— Rigidbodyë¥¼ ì¶”ê°€í•  ê²½ìš°
    * [Use Gravity] ì²´í¬ í•´ì œ
    * [Is Kinematic] ì²´í¬ : ì½”ë“œìƒìœ¼ë¡œ ì˜¤ë¸Œì íŠ¸ë¥¼ ì›€ì§ì´ì§€ ì•ŠëŠ” ì´ìƒ ì˜¤ë¸Œì íŠ¸ëŠ” ê³ ì •

  ![Object Rigidbody](C:\Users\multicampus\Desktop\Unity\Typora\Basic Character\Object Rigidbody.PNG)

 * [Rigidbody] ìš°í´ë¦­ - [Copy Component] - ëª¨ë“  ì§€í˜• ì„ íƒ í›„ [Paste Component Values]



* ë§ˆì°°ë ¥ì´ ì—†ëŠ” ë²½ ìƒì„±
  * ìºë¦­í„°ê°€ ì í”„ ì‹œ ë²½ì— ë¶™ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•¨
  * "Materials" í´ë” - ìš°í´ë¦­ [Create] - [Physics Material] ì¶”ê°€
    * ëª¨ë“  ê°’ì„ 0ìœ¼ë¡œ ë³€ê²½
    * ë§ˆì°°ë ¥ì„ ìµœì†Œë¡œ í•˜ê¸° ìœ„í•´ [Friction Combine] - "Minimum" 

![Physics Material](C:\Users\multicampus\Desktop\Unity\Typora\Basic Character\Physics Material.PNG)

* ìƒì„±í•œ Wall (Physics Material)ì„ ë²½ ì˜¤ë¸Œì íŠ¸ì˜ [Inspector] - [Box Collider] - [Material]ì—ì„œ ë³€ê²½
*  

### # 3ì¸ì¹­ ì‹œì  ì´ë™ ì½”ë“œ

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{

    public float speed;
    public float jumpPower;

    float hAxis;
    float vAxis;
    bool runDown; // runDown : Shiftë¥¼ ëˆ„ë¥´ë©´ ë‹¬ë¦¬ê¸°
    bool jumpDown; // jumpDown : Spaceë¥¼ ëˆ„ë¥´ë©´ ì í”„

    bool isJump; // ì í”„ ìˆ˜í–‰ ì—¬ë¶€

    Vector3 moveVec;

    Rigidbody rigid; // ë¬¼ë¦¬ íš¨ê³¼ë¥¼ ìœ„í•´ Rigidbody ë³€ìˆ˜ ì„ ì–¸
    Animator anim;

    void Start()
    {
        // Animator ì»´í¬ë„ŒíŠ¸ ê°€ì ¸ì˜¤ê¸°
        // Animator ì»´í¬ë„ŒíŠ¸ë¥¼ Player ì•ˆì— Childë¡œ ë„£ì–´ë†“ì•˜ê¸° ë•Œë¬¸ì— ê°€ì ¸ì˜¬ ë•Œ ë˜í•œ GetComponentê°€ ì•„ë‹Œ GetComponentInChildë¥¼ ì´ìš©í•´ì•¼ í•¨
        anim = GetComponentInChildren<Animator>();
        rigid = GetComponent<Rigidbody>(); // Childì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— GetComponent ì‚¬ìš© 
    }   

    void Update()
    {
        GetInput(); // ì œì¼ ìœ„ì— ì‘ì„±

        Move();
        Turn();  
        Jump();
    }

    void GetInput()
    {
        hAxis = Input.GetAxisRaw("Horizontal");
        vAxis = Input.GetAxisRaw("Vertical");
        runDown = Input.GetButton("Run"); // Left Shift ë²„íŠ¼ì„ ê¾¹ ëˆ„ë¥´ê³ (=>GetButton) ìˆì–´ì•¼ë§Œ ë‹¬ë¦¬ê¸° ê°€ëŠ¥ 
        jumpDown = Input.GetButtonDown("Jump"); // Spaceë¥¼ ëˆ„ë¥´ëŠ” ì¦‰ì‹œ ì í”„
    }

    void Move()
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized; // x, y, z
                                                           // normalized : ì–´ë–¤ ë°©í–¥ì´ë“  ê°™ì€ ê°’(ì†ë„)ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•¨, ë°©í–¥ ê°’ì´ 1ë¡œ ë³´ì •ëœ ë²¡í„°

        if (runDown) // ë‹¬ë¦¬ê¸°
            transform.position += moveVec * speed * 3.0f * Time.deltaTime; // transform ì´ë™ì€ ê¼­ Time.deltaTimeê¹Œì§€ ê³±í•´ì¤Œ!
        else // ê±·ê¸°
            transform.position += moveVec * speed * 1f * Time.deltaTime; // ê±·ê¸°ëŠ” ì†ë„ê°€ ë” ëŠë¦¬ê¸° ë•Œë¬¸ì— *0.3f

        // SetBool í•¨ìˆ˜ë¡œ íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •
        anim.SetBool("isWalk", moveVec != Vector3.zero);
        anim.SetBool("isRun", runDown);
    }

    void Turn()
    {
        // ë‚˜ì•„ê°€ëŠ” ë°©í–¥ì„ ë°”ë¼ë³¸ë‹¤.
        transform.LookAt(transform.position + moveVec);
    }

    void Jump()
    {
        if(jumpDown && !isJump) // Spaceë¥¼ ëˆŒë €ê³ , ì í”„ ì¤‘ì¸ ìƒíƒœê°€ ì•„ë‹ ë•Œ => ì í”„ ê°€ëŠ¥
        {
            rigid.AddForce(Vector3.up * jumpPower, ForceMode.Impulse); // AddForce í•¨ìˆ˜ë¡œ ë¬¼ë¦¬ì ì¸ í˜ì„ ê°€í•  ìˆ˜ ìˆìŒ
            isJump = true;
        }

    }

    // ì¶©ëŒ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” í•¨ìˆ˜
    private void OnCollisionEnter(Collision collision)
    {
        // ì¶©ëŒí•œ ê²Œì„ ì˜¤ë¸Œì íŠ¸ì˜ íƒœê·¸ê°€ "Floor" ì¼ ê²½ìš°
        if(collision.gameObject.tag == "Floor")
        {
            isJump = false; // ë°”ë‹¥ê³¼ ì¶©ëŒ
        }
    }
}
// ì½”ë“œ ë³´ê´€
```

![Third Person View](./Image/Third Person View.gif)

* [Hierarchy] - [Main Camera] - Child ì†ì„±ìœ¼ë¡œ ë“¤ì–´ê°€ì§€ ì•ŠìŒ

* [Main Camera] - "Follow.cs" íŒŒì¼ ì²´í¬

  

### # 1ì¸ì¹­(ë’·ëª¨ìŠµ) ì‹œì  ì´ë™ ì½”ë“œ

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{

    public float speed;
    public float jumpPower;

    float hAxis;
    float vAxis;
    bool runDown; // runDown : Shiftë¥¼ ëˆ„ë¥´ë©´ ë‹¬ë¦¬ê¸°
    bool jumpDown; // jumpDown : Spaceë¥¼ ëˆ„ë¥´ë©´ ì í”„

    bool isJump; // ì í”„ ìˆ˜í–‰ ì—¬ë¶€

    Vector3 moveVec;

    Rigidbody rigid; // ë¬¼ë¦¬ íš¨ê³¼ë¥¼ ìœ„í•´ Rigidbody ë³€ìˆ˜ ì„ ì–¸
    Animator anim;

    void Start()
    {
        // Animator ì»´í¬ë„ŒíŠ¸ ê°€ì ¸ì˜¤ê¸°
        // Animator ì»´í¬ë„ŒíŠ¸ë¥¼ Player ì•ˆì— Childë¡œ ë„£ì–´ë†“ì•˜ê¸° ë•Œë¬¸ì— ê°€ì ¸ì˜¬ ë•Œ ë˜í•œ GetComponentê°€ ì•„ë‹Œ GetComponentInChildë¥¼ ì´ìš©í•´ì•¼ í•¨
        anim = GetComponentInChildren<Animator>();
        rigid = GetComponent<Rigidbody>(); // Childì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— GetComponent ì‚¬ìš© 
    }   

    void Update()
    {
        GetInput(); // ì œì¼ ìœ„ì— ì‘ì„±

        Move(); 
        Jump();
    }

    void GetInput()
    {
        hAxis = Input.GetAxisRaw("Horizontal");
        vAxis = Input.GetAxisRaw("Vertical");
        runDown = Input.GetButton("Run"); // Left Shift ë²„íŠ¼ì„ ê¾¹ ëˆ„ë¥´ê³ (=>GetButton) ìˆì–´ì•¼ë§Œ ë‹¬ë¦¬ê¸° ê°€ëŠ¥ 
        jumpDown = Input.GetButtonDown("Jump"); // Spaceë¥¼ ëˆ„ë¥´ëŠ” ì¦‰ì‹œ ì í”„
    }

    void Move()
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized; // x, y, z
                                                           // normalized : ì–´ë–¤ ë°©í–¥ì´ë“  ê°™ì€ ê°’(ì†ë„)ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•¨, ë°©í–¥ ê°’ì´ 1ë¡œ ë³´ì •ëœ ë²¡í„°

        if (runDown) // ë‹¬ë¦¬ê¸°
            Walk(3.0f); // ë‹¬ë¦¬ê¸° ì†ë„ëŠ” ê±·ê¸°ë³´ë‹¤ ë¹ ë¥´ê¸° ë•Œë¬¸ì— 3.0f
        else // ê±·ê¸°
            Walk(1.0f); // ê±·ê¸° 1.0f ì†ë„

        // SetBool í•¨ìˆ˜ë¡œ íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •
        anim.SetBool("isWalk", moveVec != Vector3.zero);
        anim.SetBool("isRun", runDown);
    }

    void Walk(float speedVal)
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized;
        if (vAxis > 0)
        {
            this.transform.Translate(Vector3.forward * speed * speedVal * Time.deltaTime);
        }
        if(vAxis < 0)
        {
            this.transform.Translate(Vector3.back * speed * speedVal * Time.deltaTime);
        }
       if(hAxis < 0) 
        {
            if(vAxis >= 0)
            {
                // íšŒì „ ì†ë„ë¥¼ ì˜¬ë¦¬ê¸° ìœ„í•´ speedì— *10ì„ ë” í•´ì¤Œ(ì¼ë°˜ì ìœ¼ë¡œ íšŒì „ ì†ë„ë¥¼ ì´ë™ ì†ë„ë³´ë‹¤ ë” í¬ê²Œí•¨)
                this.transform.Rotate(0, -speed  * Time.deltaTime * 10, 0); // ì™¼ìª½ + ìœ„ ë°©í–¥í‚¤ : ì™¼ìª½ìœ¼ë¡œ íšŒì „
            }
            else
            {
                this.transform.Rotate(0, speed * Time.deltaTime * 10, 0); // ì™¼ìª½ + ì•„ë˜ ë°©í–¥í‚¤ : ì˜¤ë¥¸ìª½ìœ¼ë¡œ íšŒì „
            }
        }
        if (hAxis > 0)
        {
            if (vAxis >= 0)
            {
                this.transform.Rotate(0, speed * Time.deltaTime * 10, 0);  // ì˜¤ë¥¸ìª½ + ìœ„ ë°©í–¥í‚¤ : ì˜¤ë¥¸ìª½ìœ¼ë¡œ íšŒì „
            }
            else
            {
                this.transform.Rotate(0, -speed * Time.deltaTime * 10, 0); // ì˜¤ë¥¸ìª½ + ì•„ë˜ ë°©í–¥í‚¤ : ì™¼ìª½ìœ¼ë¡œ íšŒì „ 
            }
        }
    }


	// ì í”„ëŠ” ì œëŒ€ë¡œ ì‘ë™ ì•ˆ í•  ìˆ˜ ìˆìŒ.. ìˆ˜ì • ì˜ˆì •
    void Jump()
    {
        if(jumpDown && !isJump) // Spaceë¥¼ ëˆŒë €ê³ , ì í”„ ì¤‘ì¸ ìƒíƒœê°€ ì•„ë‹ ë•Œ => ì í”„ ê°€ëŠ¥
        {
            rigid.AddForce(Vector3.up * jumpPower, ForceMode.Impulse); // AddForce í•¨ìˆ˜ë¡œ ë¬¼ë¦¬ì ì¸ í˜ì„ ê°€í•  ìˆ˜ ìˆìŒ
            isJump = true;
        }

    }

    // ì¶©ëŒ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” í•¨ìˆ˜
    private void OnCollisionEnter(Collision collision)
    {
        // ì¶©ëŒí•œ ê²Œì„ ì˜¤ë¸Œì íŠ¸ì˜ íƒœê·¸ê°€ "Floor" ì¼ ê²½ìš°
        if(collision.gameObject.tag == "Floor")
        {
            isJump = false; // ë°”ë‹¥ê³¼ ì¶©ëŒ
        }
    }
}

```

![First Person](./Image/First Person.gif)

* [Hierarchy] - ìºë¦­í„° ë‚´ë¶€ë¡œ [Main Camera] ì´ë™ 
* "Follow.cs" íŒŒì¼ ì²´í¬ í•´ì œ



### 16. í”Œë ˆì´ì–´ ìë™ íšŒì „ ë°©ì§€

* ì˜¤ë¸Œì íŠ¸ì™€ ë¶€ë”ªí˜”ì„ ë•Œ [Capsule Collider]ì— ì˜í•´ì„œ ìºë¦­í„°ê°€ íšŒì „í•˜ëŠ” ë¬¸ì œë¥¼ ë°©ì§€

```c#
void FreezeRotation()
{
    // angularVelocity : ë¬¼ë¦¬ íšŒì „ ì†ë„
    rigid.angularVelocity = Vector3.zero; // íšŒì „ ì†ë„ë¥¼ 0ë¡œ ìœ ì§€
}
void FixedUpdate()
{
    FreezeRotation();
}
```

 

### 17. í”Œë ˆì´ì–´ ë²½ ê´€í†µ ë°©ì§€

* DrawRay() : Scene ë‚´ì—ì„œ Rayë¥¼ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜
*  Raycast() : Rayë¥¼ ì˜ì•„ ë‹¿ëŠ” ì˜¤ë¸Œì íŠ¸ë¥¼ ê°ì§€í•˜ëŠ” í•¨ìˆ˜
  * "Wall" ì´ë¼ëŠ” LayerMaskë¥¼ ê°€ì§„ ì˜¤ë¸Œì íŠ¸ì™€ ì¶©ëŒí•˜ê²Œ ë˜ë©´ isBorder = trueë¡œ ë³€ê²½

* ëª¨ë“  ë²½ ì˜¤ë¸Œì íŠ¸ì˜ Layerì„ "Wall"ë¡œ ë³€ê²½ì‹œì¼œì£¼ì–´ì•¼ í•¨
  * [Inspector] - [Layer] - [Add Layer] - "Wall" ì¶”ê°€ í›„ ë³€ê²½

![Wall Layer](./Image/Wall Layer.PNG)

```c#

    bool isBorder; // ë²½ ì¶©ëŒ í”Œë˜ê·¸
    
    void Walk(float speedVal)
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized;
        if (vAxis > 0)
        {
            // 1ì¸ì¹­ì´ê¸° ë•Œë¬¸ì— ìºë¦­í„°ê°€ ì´ë™í•˜ë ¤ë©´ ë¬´ì¡°ê±´ ìœ„ ë°©í–¥í‚¤ë¥¼ ëˆŒëŸ¬ì•¼ í•¨
            // ë”°ë¼ì„œ isBorder í”Œë˜ê·¸ ë˜í•œ ì•ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê²½ìš°ì—ë§Œ ì¡°ê±´ ì‚¬ìš©í•˜ë©´ ë¨
            // ë‹¤ë¥¸ ì´ë™ ë°©í–¥(ì˜ˆë¥¼ ë“¤ì–´, ë’¤ë¡œ ì´ë™)ì— if(!isBorder) ì¡°ê±´ì„ ë„£ìœ¼ë©´ ì›€ì§ì„ì´ ì´ìƒí•´ì§ 
            if (!isBorder) // Rayê°€ ë²½ì— ë¶€ë”ªíˆì§€ ì•Šì•˜ë‹¤ë©´
            {
                this.transform.Translate(Vector3.forward * speed * speedVal * Time.deltaTime);
            }
        }
        ....
    }

    void StopToWall()
    {
        Debug.DrawRay(transform.position, transform.forward * 5, Color.green); // Scene ë‚´ì—ì„œ Rayë¥¼ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜
        isBorder = Physics.Raycast(transform.position, transform.forward, 5, LayerMask.GetMask("Wall")); 

    }

    void FixedUpdate()
    {
        FreezeRotation();
        StopToWall();
    }

```

![Player Ray Result](./Image/Player Ray Result.gif)



------

### 18. 1~17ê¹Œì§€ ì „ì²´ ì½”ë“œ

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{

    public float speed;
    public float jumpPower;

    float hAxis;
    float vAxis;
    bool runDown; // runDown : Shiftë¥¼ ëˆ„ë¥´ë©´ ë‹¬ë¦¬ê¸°
    bool jumpDown; // jumpDown : Spaceë¥¼ ëˆ„ë¥´ë©´ ì í”„
    bool dodgeDown;

    bool isJump; // ì í”„ ìˆ˜í–‰ ì—¬ë¶€
    bool isDodge; // íšŒí”¼ ìˆ˜í–‰ ì—¬ë¶€

    bool isBorder; // ë²½ ì¶©ëŒ í”Œë˜ê·¸

    Vector3 moveVec;

    Rigidbody rigid; // ë¬¼ë¦¬ íš¨ê³¼ë¥¼ ìœ„í•´ Rigidbody ë³€ìˆ˜ ì„ ì–¸
    Animator anim;

    void Start()
    {
        // Animator ì»´í¬ë„ŒíŠ¸ ê°€ì ¸ì˜¤ê¸°
        // Animator ì»´í¬ë„ŒíŠ¸ë¥¼ Player ì•ˆì— Childë¡œ ë„£ì–´ë†“ì•˜ê¸° ë•Œë¬¸ì— ê°€ì ¸ì˜¬ ë•Œ ë˜í•œ GetComponentê°€ ì•„ë‹Œ GetComponentInChildë¥¼ ì´ìš©í•´ì•¼ í•¨
        anim = GetComponentInChildren<Animator>();
        rigid = GetComponent<Rigidbody>(); // Childì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— GetComponent ì‚¬ìš© 
    }   

    void Update()
    {
        GetInput(); // ì œì¼ ìœ„ì— ì‘ì„±


        Move();
        Jump();
        Dodge();
    }

    void GetInput()
    {
        hAxis = Input.GetAxisRaw("Horizontal");
        vAxis = Input.GetAxisRaw("Vertical");
        runDown = Input.GetButton("Run"); // Left Shift ë²„íŠ¼ì„ ê¾¹ ëˆ„ë¥´ê³ (=>GetButton) ìˆì–´ì•¼ë§Œ ë‹¬ë¦¬ê¸° ê°€ëŠ¥ 
        jumpDown = Input.GetButtonDown("Jump"); // Spaceë¥¼ ëˆ„ë¥´ëŠ” ì¦‰ì‹œ ì í”„
        dodgeDown = Input.GetButtonDown("Dodge"); // Që¥¼ ëˆ„ë¥´ë©´ íšŒí”¼ ë™ì‘
    }

    void Move()
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized; // x, y, z
                                                           // normalized : ì–´ë–¤ ë°©í–¥ì´ë“  ê°™ì€ ê°’(ì†ë„)ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•¨, ë°©í–¥ ê°’ì´ 1ë¡œ ë³´ì •ëœ ë²¡í„°
 

        if (runDown) // ë‹¬ë¦¬ê¸°
            Walk(1.5f); // ë‹¬ë¦¬ê¸° ì†ë„ëŠ” ê±·ê¸°ë³´ë‹¤ ë¹ ë¥´ê¸° ë•Œë¬¸ì— 3.0f
        else // ê±·ê¸°
            Walk(0.8f); // ê±·ê¸° 1.0f ì†ë„
        

        // SetBool í•¨ìˆ˜ë¡œ íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •
        anim.SetBool("isWalk", moveVec != Vector3.zero);
        anim.SetBool("isRun", runDown);
    }

    void Walk(float speedVal)
    {
        moveVec = new Vector3(hAxis, 0, vAxis).normalized;
        if (vAxis > 0)
        {
            if (!isBorder)
            {
                this.transform.Translate(Vector3.forward * speed * speedVal * Time.deltaTime);
            }
        }
        if (vAxis < 0)
        {
           
             this.transform.Translate(Vector3.back * speed * speedVal * Time.deltaTime);

            
        }
       if(hAxis < 0) 
        {
            if (vAxis >= 0)
            {
                
                // íšŒì „ ì†ë„ë¥¼ ì˜¬ë¦¬ê¸° ìœ„í•´ speedì— *10ì„ ë” í•´ì¤Œ(ì¼ë°˜ì ìœ¼ë¡œ íšŒì „ ì†ë„ë¥¼ ì´ë™ ì†ë„ë³´ë‹¤ ë” í¬ê²Œí•¨)
                this.transform.Rotate(0, -speed * Time.deltaTime * 10, 0); // ì™¼ìª½ + ìœ„ ë°©í–¥í‚¤ : ì™¼ìª½ìœ¼ë¡œ íšŒì „
                
            }
            else
            {
                 this.transform.Rotate(0, speed * Time.deltaTime * 10, 0); // ì™¼ìª½ + ì•„ë˜ ë°©í–¥í‚¤ : ì˜¤ë¥¸ìª½ìœ¼ë¡œ íšŒì „
            }
        }
        if (hAxis > 0)
        {
            if (vAxis >= 0)
            {

                this.transform.Rotate(0, speed * Time.deltaTime * 10, 0);  // ì˜¤ë¥¸ìª½ + ìœ„ ë°©í–¥í‚¤ : ì˜¤ë¥¸ìª½ìœ¼ë¡œ íšŒì „
            }
            else
            {
                this.transform.Rotate(0, -speed * Time.deltaTime * 10, 0); // ì˜¤ë¥¸ìª½ + ì•„ë˜ ë°©í–¥í‚¤ : ì™¼ìª½ìœ¼ë¡œ íšŒì „ 
            }
        }
    }



    void Jump()
    {
        if(jumpDown  && !isJump && !isDodge) // Spaceë¥¼ ëˆŒë €ê³ , ì í”„ ì¤‘ì¸ ìƒíƒœê°€ ì•„ë‹ ë•Œ => ì í”„ ê°€ëŠ¥ 
                                                                       // íšŒí”¼í•˜ëŠ” ë„ì¤‘ì—ëŠ” ì í”„ ë¶ˆê°€ëŠ¥
        {
            rigid.AddForce(Vector3.up * jumpPower, ForceMode.Impulse); // AddForce í•¨ìˆ˜ë¡œ ë¬¼ë¦¬ì ì¸ í˜ì„ ê°€í•  ìˆ˜ ìˆìŒ
            anim.SetBool("isJump", true);
            anim.SetTrigger("doJump");
            isJump = true;
        }

    }

    void Dodge()
    {
        if (dodgeDown && !isJump && !isDodge) 
        {
            speed *= 2; // íšŒí”¼ì˜ ì†ë„ëŠ” 2ë°° ë¹ ë¦„
            anim.SetTrigger("doDodge");
            isDodge = true;

            Invoke("DodgeOut", 0.4f); // ì‹œê°„ì°¨ í•¨ìˆ˜ í˜¸ì¶œ (í•¨ìˆ˜ëª…, ì‹œê°„ì°¨)

        }

    }

    void DodgeOut()
    {
        speed /= 2; // ì›ë˜ ì†ë„ë¡œ ë˜ëŒë¦¼
        isDodge = false;
    }

    // ì¶©ëŒ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” í•¨ìˆ˜
    private void OnCollisionEnter(Collision collision)
    {
        // ì¶©ëŒí•œ ê²Œì„ ì˜¤ë¸Œì íŠ¸ì˜ íƒœê·¸ê°€ "Floor" ì¼ ê²½ìš°
        if(collision.gameObject.tag == "Floor")
        {
            isJump = false; // ë°”ë‹¥ê³¼ ì¶©ëŒ
            anim.SetBool("isJump", false);
        }
    }

    // í”Œë ˆì´ì–´ íšŒì „ ë°©ì§€
    void FreezeRotation()
    {
        // angularVelocity : ë¬¼ë¦¬ íšŒì „ ì†ë„
        rigid.angularVelocity = Vector3.zero; // íšŒì „ ì†ë„ë¥¼ 0ë¡œ ìœ ì§€
    }

    void StopToWall()
    {

        Debug.DrawRay(transform.position, transform.forward * 5, Color.red); // Scene ë‚´ì—ì„œ Rayë¥¼ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜
        isBorder = Physics.Raycast(transform.position, transform.forward, 5, LayerMask.GetMask("Wall")); 
        // Raycast() : Rayë¥¼ ì˜ì•„ ë‹¿ëŠ” ì˜¤ë¸Œì íŠ¸ë¥¼ ê°ì§€í•˜ëŠ” í•¨ìˆ˜
        // "Wall" ì´ë¼ëŠ” LayerMaskë¥¼ ê°€ì§„ ì˜¤ë¸Œì íŠ¸ì™€ ì¶©ëŒí•˜ê²Œ ë˜ë©´ isBorder = trueë¡œ ë³€ê²½

    }

    void FixedUpdate()
    {
        FreezeRotation();
        StopToWall();
    }

}

```



